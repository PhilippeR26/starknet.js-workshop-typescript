// Deploy & test a customized account.
// Pedagogical account abstraction (must not be used to hold valuable assets).
// This account uses a signature made of an array of 4 felts.
// - The 2 first felts are a normal r,s Starknet transaction signature.
// - The 2 last felts are generated by a hardware signer, that uses as input the transaction nonce, and as output its starknet signature.
// So, 
// - If the hardware signer is not connected, it's impossible to process a transaction, even if the private key of the account has been stolen. 
// - If the hardware wallet is stolen, it can't be used with the account (as the account private key is also necessary).
// - So it's necessary to steal both the account private key and the hardware wallet to process any transaction.
//
// constructor: 2 felts : first the account public key, then the hardware signer public key.
//
// The hardware wallet must be used only with ONE single account, to be sure to use a nonce signature only once.
//
// launch with npx ts-node src/scripts/10.createAccountAbstraction.ts
// Coded with Starknet.js v8.5.0 & Devnet 0.5.0

import { Account, ec, json, hash, CallData, RpcProvider, shortString, config, CairoBytes31, type CompiledSierra, type CairoAssembly, stark, Contract, type InvokeFunctionResponse, type SuccessfulTransactionReceiptResponse } from "starknet";
import { Devnet } from "starknet-devnet";
import { DEVNET_PORT, DEVNET_VERSION } from "../constants";
import fs from "fs";
import cp from "child_process";
import events from "events";
import kill from "cross-port-killer";
import * as dotenv from "dotenv";
import { HardwareSigner } from "./Starknet140/Starknet140-devnet/5a.HardwareSigner";
import { SpecialSigner } from "./Starknet140/Starknet140-devnet/5b.CustomSigner";
import { strkAddress } from "./utils/constants";
dotenv.config();

async function main() {
    // launch Devnet with a new console window
    const outputStream = fs.createWriteStream("./src/scripts/devnet-out.txt");
    await events.once(outputStream, "open");
    // the following line is working in Linux. To adapt or remove for other OS
    cp.spawn("gnome-terminal", ["--", "bash", "-c", "pwd; tail -f ./src/scripts/devnet-out.txt; read"]);
    const devnet = await Devnet.spawnVersion(DEVNET_VERSION, {
        stdout: outputStream,
        stderr: outputStream,
        keepAlive: false,
        args: ["--seed", "0", "--port", DEVNET_PORT]
    });
    const myProvider = new RpcProvider({ nodeUrl: devnet.provider.url });
    config.set("logLevel", "FATAL");
    console.log("Devnet : url =", devnet.provider.url);
    console.log(
        "chain Id =", new CairoBytes31(await myProvider.getChainId()).decodeUtf8(),
        ", rpc", await myProvider.getSpecVersion(),
        ", SN version =", (await myProvider.getBlock()).starknet_version);
    console.log("Provider connected to Starknet-Devnet");

    // initialize existing predeployed account 0 of Devnet
    const devnetAccounts = await devnet.provider.getPredeployedAccounts();
    const account0 = new Account({
        provider: myProvider,
        address: devnetAccounts[0].address,
        signer: devnetAccounts[0].private_key
    });
    console.log("Account 0 connected.\nAddress =", account0.address, "\n");

    // My customized Cairo v2.12.0 account, 
    // using an additional hardware signer 
    // Cairo source code of the abstracted account is here: ./contracts/cairo2120/account_abstraction

    // Declare my wallet contract
    const compiledSierra = json.parse(fs.readFileSync("./compiledContracts/cairo2120/account_abstraction_MyAccountAbstraction.contract_class.json").toString("ascii")) as CompiledSierra;
    const compiledCasm = json.parse(fs.readFileSync("./compiledContracts/cairo2120/account_abstraction_MyAccountAbstraction.compiled_contract_class.json").toString("ascii")) as CairoAssembly;
    // const AAaccountClashHash = "0x6e344dd665ac8aa1ff6488be0538275ee6c5e53ef7bfa0d8df6cc0f6997826e";
    const { transaction_hash: declTH, class_hash: decCH } = await account0.declareIfNot({ contract: compiledSierra, casm: compiledCasm });
    if (declTH) {
        await myProvider.waitForTransaction(declTH);
    } else {
        console.log("Already declared");
    };
    const classHash = decCH;
    console.log({ classHash });

    // Generate public and private key pair.
    const AAprivateKey = process.env.AA_NEW_ACCOUNT_PRIVKEY ?? "";
    // or for random private key :
    // const privateKey=stark.randomAddress() ;
    console.log('privateKey=', AAprivateKey);
    const AAstarkKeyPub = ec.starkCurve.getStarkKey(AAprivateKey);
    console.log('publicKey=', AAstarkKeyPub);
    // Create a signer that simulate the behavior of a hardware signer connected to the computer
    const hwPrivateKey = stark.randomAddress();
    console.log({ hwPrivateKey });
    const hardwareSigner = new HardwareSigner(hwPrivateKey);
    const hwPublicKey = await hardwareSigner.getPubKey();
    console.log({ hwPublicKey });
    // Create a custom signer for this account abstraction
    const specialSigner = new SpecialSigner(AAprivateKey, hardwareSigner);

    const accountCallData = new CallData(compiledSierra.abi);
    // custom account constructor, with 2 public keys ; one related to the account private key, one related to the hardware signer.
    const constructorCallData = accountCallData.compile("constructor", {
        public_key: AAstarkKeyPub,
        hardware_public_key: hwPublicKey,
    });
    console.log("constructor =", constructorCallData);
    const accountAddress = hash.calculateContractAddressFromHash(AAstarkKeyPub, classHash, constructorCallData, 0);
    console.log('Precalculated account address=', accountAddress);

    // fund account address before account creation
    await devnet.provider.mint(accountAddress, 10n * 10n ** 18n, "WEI"); // 10 ETH
    await devnet.provider.mint(accountAddress, 100n * 10n ** 18n, "FRI"); // 100 STRK
    // deploy account
    const abstractedAccount = new Account({
        provider: myProvider,
        address: accountAddress,
        signer: specialSigner
    });
    console.log("Deploy account...");
    const { transaction_hash, contract_address } = await abstractedAccount.deployAccount({
        classHash: classHash,
        constructorCalldata: constructorCallData,
        addressSalt: AAstarkKeyPub,
        contractAddress: accountAddress
    });
    console.log('âœ… New special account created.\n   Final address =', contract_address);
    await myProvider.waitForTransaction(transaction_hash);

    // Test account
    const erc20Sierra = json.parse(fs.readFileSync("./compiledContracts/cairo210/erc20OZ070decimals.sierra.json").toString("ascii")) as CompiledSierra;
    const strkContract = new Contract({
        abi: erc20Sierra.abi,
        address: strkAddress,
        providerOrAccount: account0,
    });
    const transferCall = strkContract.populate("transfer", {
        recipient: account0.address,
        amount: 20n * 10n ** 16n,
    });
    const { transaction_hash: txH }: InvokeFunctionResponse = await abstractedAccount.execute([transferCall], {}); // you can add other txs here
    const txR = await myProvider.waitForTransaction(txH);
    txR.match(
        {
            "SUCCEEDED": (txR: SuccessfulTransactionReceiptResponse) => {
                console.log("TxH =", txR.transaction_hash, "\nStatus =", txR.execution_status);
            },
            _: () => {
                console.log("Tx failed.");
            }
        }
    );


    outputStream.end();
    const pid: string[] = await kill(DEVNET_PORT);
    console.log("Devnet stopped. Pid :", pid, "\nYou can close the log window.");
}
main()
    .then(() => process.exit(0))
    .catch((error) => {
        console.error(error);
        process.exit(1);
    });

