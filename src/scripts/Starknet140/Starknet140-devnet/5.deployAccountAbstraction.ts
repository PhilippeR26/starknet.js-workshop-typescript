// Deploy & test a customized account.
// Pedagogical account abstraction (must not be used to hold valuable assets).
// This account uses a signature made of an array of 4 felts.
// - The 2 first felts are a normal r,s Starknet transaction signature.
// - The 2 last felts are generated by a hardware signer, that uses as input the transaction nonce, and as output its starknet signature.
// So, 
// - If the hardware signer is not connected, it's impossible to process a transaction, even if the private key of the account has been stolen. 
// - If the hardware wallet is stolen, it can't be used with the account (as the account private key is also necessary).
// - So it's necessary to steal both the account private key and the hardware wallet to process any transaction.
//
// constructor: 2 felts : first the account public key, then the hardware signer public key.
//
// The hardware wallet must be used only with ONE single account, to be sure to use a nonce signature only once.
//
// Launch with : npx ts-node src/scripts/Starknet140/Starknet140-devnet/5.deployAccountAbstraction.ts
// Coded with Starknet.js v8.5.0

import { RpcProvider, Account, json, Contract, shortString, type CompiledSierra, type CairoAssembly, BlockTag, type Call, type Nonce, logger, stark, ec, CallData, hash, type InvokeFunctionResponse, type SuccessfulTransactionReceiptResponse } from "starknet";
import fs from "fs";
import axios from "axios";
import * as dotenv from "dotenv";
import { strkAddress } from "../../utils/constants";
import { wait } from "../../utils/utils";
import { account2TestBraavosSepoliaAddress, account2TestBraavosSepoliaPrivateKey, account3ArgentXSepoliaAddress, equilibriumPathfinderTestnetUrl, spaceShardJunoTestnetNodeUrl, spaceShardPathfinderTestnetNodeUrl } from "../../../A1priv/A1priv";
import { DevnetProvider } from "starknet-devnet";
import { alchemyKey, infuraKey } from "../../../A-MainPriv/mainPriv";
// Simulation of a Hardware wallet 
import { HardwareSigner } from "./5a.HardwareSigner";
// Custom signer for this account
import { SpecialSigner } from "./5b.CustomSigner";
dotenv.config();


async function main() {
    // *** devnet
    const url = "http://127.0.0.1:5050/rpc";
    const l2DevnetProvider = new DevnetProvider({ timeout: 40_000 });

    // *** local 
    // ðŸš¨ðŸš¨ðŸš¨ Put here the url of your node.
    //          ðŸ‘‡ðŸ‘‡ðŸ‘‡
    // const url = "http://192.168.1.34:9545/rpc/v0_9"; // local Pathfinder Testnet node (Starlink network)
    // const url = "http://localhost:9545/rpc/v0_9"; // local Pathfinder Testnet node (Starlink network)
    // const url = "http://192.168.1.34:6070/rpc/v0_9"; // my local Juno Sepolia Testnet node (Starlink network)
    // const url = "http://localhost:6070/rpc/v0_9"; // my local Juno Sepolia Testnet node (Starlink network)
    // const url = equilibriumPathfinderTestnetUrl; // Pathfinder testnet from Equilibrium team
    // const url = spaceShardPathfinderTestnetNodeUrl; // private Pathfinder testnet from SpaceShard team
    // const url = spaceShardJunoTestnetNodeUrl; // private Pathfinder testnet from SpaceShard team
    // const url = "https://starknet-sepolia.public.blastapi.io/rpc/v0_9"; // Public Blast Pathfinder testnet
    // const url = "https://starknet-sepolia.g.alchemy.com/starknet/version/rpc/v0_9/" + alchemyKey; // Alchemy
    // const url = "https://starknet-sepolia.infura.io/v3/" + infuraKey; // Infura (rpc 0.8.1)
    // const url="https://rpc.starknet-testnet.lava.build/rpc/v0_9"; // Lava (no guaranty of rpc version usage)
    const myProvider = new RpcProvider({
        nodeUrl: url,
        specVersion: "0.9.0",
        blockIdentifier: BlockTag.LATEST,
    });
    // const myProvider = new RpcProvider({ nodeUrl: url, specVersion: "0.9.0" }); // my local Pathfinder Sepolia Testnet node (Starlink network)
    // const myProvider = new RpcProvider({ nodeUrl: "http://127.0.0.0:9545/rpc/v0_9", specVersion: "0.9.0" }); // local Pathfinder Sepolia Testnet node
    // public node
    // const myProvider = new RpcProvider({ nodeUrl: "https://starknet-sepolia.public.blastapi.io/rpc/v0_9", specVersion: "0.9.0" }); // Sepolia Testnet 


    if (!(await l2DevnetProvider.isAlive())) {
        console.log("No l2 devnet.");
        process.exit();
    }
    console.log(
        "chain Id =", shortString.decodeShortString(await myProvider.getChainId()),
        ", rpc", await myProvider.getSpecVersion(),
        ", SN version =", (await myProvider.getBlock()).starknet_version);
    console.log("Provider connected to Starknet");

    // *** initialize existing predeployed account 0 of Devnet
    const accData = await l2DevnetProvider.getPredeployedAccounts();
    const accountAddress0 = accData[0].address;
    const privateKey0 = accData[0].private_key;

    // *** initialize existing Sepolia Integration account
    // const accountAddress0 = account3IntegrationOZ17address;
    // const privateKey0 = account3IntegrationOZ17privateKey;
    // **** Sepolia
    // ðŸš¨ðŸš¨ðŸš¨ Put here the address & the private key of your account.
    //          ðŸ‘‡ðŸ‘‡ðŸ‘‡
    // const accountAddress0 = account2TestBraavosSepoliaAddress;
    // const privateKey0 = account2TestBraavosSepoliaPrivateKey;
    // **** Mainnet
    //  const accountAddress0 = account1BraavosMainnetAddress;
    //  const privateKey0 = account1BraavosMainnetPrivateKey;

    const account0 = new Account({ provider: myProvider, address: accountAddress0, signer: privateKey0 });
    console.log("Account 0 connected.\n");


    // ***** main code : 
    // class hash: 0x6e344dd665ac8aa1ff6488be0538275ee6c5e53ef7bfa0d8df6cc0f6997826e
    // Cairo source code of the abstracted account is here: ./contracts/cairo2120/account_abstraction
    const compiledSierra = json.parse(fs.readFileSync("./compiledContracts/cairo2120/account_abstraction_MyAccountAbstraction.contract_class.json").toString("ascii")) as CompiledSierra;
    const compiledCasm = json.parse(fs.readFileSync("./compiledContracts/cairo2120/account_abstraction_MyAccountAbstraction.compiled_contract_class.json").toString("ascii")) as CairoAssembly;
    const resDecl = await account0.declareIfNot({
        contract: compiledSierra,
        casm: compiledCasm,
    });
    if (resDecl.transaction_hash) {
        console.log("new class hash =", resDecl.class_hash);
        await myProvider.waitForTransaction(resDecl.transaction_hash);
    } else {
        console.log("Already declared");
    };
    const classHash = resDecl.class_hash;
    console.log({ classHash });
    // const contractAddr = "";

    // Connect the new contract instance :
    console.log("Deploy account...");
    // Generate public and private key pair.
    // const privateKey = "0x12345789012345678901234";
    const privateKey = stark.randomAddress();
    console.log('New account :\nprivateKey =', privateKey);
    const starkKeyPub = ec.starkCurve.getStarkKey(privateKey);
    console.log('publicKey =', starkKeyPub);
    // Create a signer that simulate the behavior of a hardware signer connected to the computer
    // const hwPrivateKey = "0x12345789012345678901234abc";
    const hwPrivateKey = stark.randomAddress();
    console.log({ hwPrivateKey });
    const hardwareSigner = new HardwareSigner(hwPrivateKey);
    const hwPublicKey = await hardwareSigner.getPubKey();
    console.log({ hwPublicKey });
    // Create a custom signer for this account abstraction
    const specialSigner = new SpecialSigner(privateKey, hardwareSigner);
    // Calculate future address of the account
    const accountCallData = new CallData(compiledSierra.abi);
    const constructorCallData = accountCallData.compile("constructor", {
        public_key: starkKeyPub,
        hardware_public_key: hwPublicKey,
    });
    console.log("constructor =", constructorCallData);
    const accountAddress = hash.calculateContractAddressFromHash(starkKeyPub, resDecl.class_hash, constructorCallData, 0);
    console.log('Precalculated account address=', accountAddress);

    // Fund account address before account creation
    await l2DevnetProvider.mint(accountAddress, 10n * 10n ** 18n, "WEI"); // 10 ETH
    await l2DevnetProvider.mint(accountAddress, 100n * 10n ** 18n, "FRI"); // 100 STRK

    // Deploy account
    const abstractedAccount = new Account({
        provider: myProvider,
        address: accountAddress,
        signer: specialSigner
    });
    console.log("Deploy account...");
    const { transaction_hash, contract_address } = await abstractedAccount.deployAccount({
        classHash: resDecl.class_hash,
        constructorCalldata: constructorCallData,
        addressSalt: starkKeyPub,
        contractAddress: accountAddress
    });
    console.log('âœ… New special account created.\n   Final address =', contract_address);
    await myProvider.waitForTransaction(transaction_hash);

    // Test account
    const erc20Sierra = json.parse(fs.readFileSync("./compiledContracts/cairo210/erc20OZ070decimals.sierra.json").toString("ascii")) as CompiledSierra;
    const strkContract = new Contract({
        abi: erc20Sierra.abi,
        address: strkAddress,
        providerOrAccount: account0,
    });
    const transferCall = strkContract.populate("transfer", {
        recipient: account0.address,
        amount: 20n * 10n ** 16n,
    });
    const { transaction_hash: txH }: InvokeFunctionResponse = await abstractedAccount.execute([transferCall], {}); // you can add other txs here
    const txR = await myProvider.waitForTransaction(txH);
    txR.match(
        {
            "SUCCEEDED": (txR: SuccessfulTransactionReceiptResponse) => {
                console.log("TxH =", txR.transaction_hash, "\nStatus =", txR.execution_status);
            },
            _: () => {
                console.log("Tx failed.");
            }
        }
    )

    console.log('âœ… Test completed.');
}
main()
    .then(() => process.exit(0))
    .catch((error) => {
        console.error(error);
        process.exit(1);
    });
