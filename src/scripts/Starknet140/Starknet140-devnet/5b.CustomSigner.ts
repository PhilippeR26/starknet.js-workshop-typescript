// Custom signer for Account Abstraction.
// For a custom account that uses a signature made of an array of 4 felts.
// - The 2 first felts are a normal r,s Starknet transaction signature.
// - The 2 last felts are generated by a hardware signer, that uses as input the transaction nonce, and as output its starknet signature.

import {
  Call,
  DeclareSignerDetails,
  DeployAccountSignerDetails,
  hash,
  InvocationsSignerDetails,
  num,
  Signature,
  stark,
  transaction,
  TypedData,
  V3DeclareSignerDetails,
  V3DeployAccountSignerDetails,
  V3InvocationsSignerDetails,
  type BigNumberish,
} from 'starknet';
import { ETransactionVersion3, typedData as snjsTypedData } from 'starknet';
import { CallData, ec, encode } from 'starknet';
import { SignerInterface } from 'starknet';
import type { HardwareSigner } from './5a.HardwareSigner';

export class SpecialSigner implements SignerInterface {
  protected pk: Uint8Array | string;
  protected hwSigner: HardwareSigner;

  constructor(pk: Uint8Array | string = ec.starkCurve.utils.randomPrivateKey(), hardwareSigner: HardwareSigner) {
    this.pk = pk instanceof Uint8Array ? encode.buf2hex(pk) : num.toHex(pk);
    this.hwSigner = hardwareSigner;
  }

  public async getPubKey(): Promise<string> {
    return ec.starkCurve.getStarkKey(this.pk);
  }

  public async signMessage(typedData: TypedData, accountAddress: string): Promise<Signature> {
    const msgHash = snjsTypedData.getMessageHash(typedData, accountAddress);
    return this.signRaw(msgHash, 0);
  }

  public async signTransaction(
    transactions: Call[],
    details: InvocationsSignerDetails
  ): Promise<Signature> {
    const compiledCalldata = transaction.getExecuteCalldata(transactions, details.cairoVersion);
    let msgHash;

    // TODO: How to do generic union discriminator for all like this
    if (Object.values(ETransactionVersion3).includes(details.version as any)) {
      const det = details as V3InvocationsSignerDetails;
      msgHash = hash.calculateInvokeTransactionHash({
        ...det,
        senderAddress: det.walletAddress,
        compiledCalldata,
        version: det.version,
        nonceDataAvailabilityMode: stark.intDAM(det.nonceDataAvailabilityMode),
        feeDataAvailabilityMode: stark.intDAM(det.feeDataAvailabilityMode),
      });
    } else {
      throw Error('unsupported signTransaction version');
    }

    return this.signRaw(msgHash as string, details.nonce);
  }

  public async signDeployAccountTransaction(
    details: DeployAccountSignerDetails
  ): Promise<Signature> {
    const compiledConstructorCalldata = CallData.compile(details.constructorCalldata);
    /*     const version = BigInt(details.version).toString(); */
    let msgHash;

    if (Object.values(ETransactionVersion3).includes(details.version as any)) {
      const det = details as V3DeployAccountSignerDetails;
      msgHash = hash.calculateDeployAccountTransactionHash({
        ...det,
        salt: det.addressSalt,
        compiledConstructorCalldata,
        version: det.version,
        nonceDataAvailabilityMode: stark.intDAM(det.nonceDataAvailabilityMode),
        feeDataAvailabilityMode: stark.intDAM(det.feeDataAvailabilityMode),
      });
    } else {
      throw Error('unsupported signDeployAccountTransaction version');
    }

    return this.signRaw(msgHash as string, details.nonce);
  }

  public async signDeclareTransaction(
    // contractClass: ContractClass,  // Should be used once class hash is present in ContractClass
    details: DeclareSignerDetails
  ): Promise<Signature> {
    let msgHash;

    if (Object.values(ETransactionVersion3).includes(details.version as any)) {
      const det = details as V3DeclareSignerDetails;
      msgHash = hash.calculateDeclareTransactionHash({
        ...det,
        version: det.version,
        nonceDataAvailabilityMode: stark.intDAM(det.nonceDataAvailabilityMode),
        feeDataAvailabilityMode: stark.intDAM(det.feeDataAvailabilityMode),
      });
    } else {
      throw Error('unsupported signDeclareTransaction version');
    }

    return this.signRaw(msgHash as string, details.nonce);
  }

  protected async signRaw(msgHash: string, nonce: BigNumberish): Promise<Signature> {
    // Calculate the normal starknet signature
    const accountSignature = stark.signatureToHexArray(ec.starkCurve.sign(msgHash, this.pk));
    // Ask to the Hardware signer a signature for this nonce
    const hardwareSignature = stark.signatureToHexArray(await this.hwSigner.signNonce(nonce));
    // Build the full signature, made of 4 felts
    const finalSignature = [...accountSignature, ...hardwareSignature];
    console.log({ finalSignature });
    return finalSignature;
  }
}
